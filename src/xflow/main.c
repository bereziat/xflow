/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 * $Id: main.c,v 1.16 2010/10/18 19:47:42 bereziat Exp $
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>

#include <assert.h>
#include "interface.h"
#include "support.h"
#include "data.h"
#include "utils.h"

static char usage[]  = "[options|--help|--version] images";
static char detail[] = "images can be a list of any INRIMAGE file or XFLOW2 image.\n\
  - an XFLOW2 image will be displayed as a vector field. \n\
    If several XFLOW images are specified, vector fields \n\
    are surperposed.\n\
  - an INRIMAGE image will be displayed as a background image.\n\
    If several INRIMAGE images are specified, the first one is\n\
    displayed (other image can be selected inside xflow)\n\
  \n\
Options are:\n\
  -sample %d: set value of sample parameter (1-30)\n\
  -scale %f:  set value of scale parameter\n\
  -tlow %f:   set value of low threshold parameter\n\
  -thigh %f:  set value of high threshold parameter\n\
  -zoom %f:   set zoom parameter (1-20)\n\
  -smooth:    smooth vector fields\n\
  -norma:     normalize vector fields\n\
";

int debug = 0;

/* Une variable globale qui contient toute
   les infos pour l'API : faudra l'instancier un jour */
XFLOW_API api;

int
main (int argc, char *argv[])
{
  GtkWidget *widget;
  char name[256], version[10];
  XFLOW_DATA *data;
  int isimg, norma, smooth;
  int color;
  Fort_int lfmt[9];
  
  //  initopts( argc, argv);
  sprintf( version, "%d.%d.%d %s", XFLOW_API_MAJOR, XFLOW_API_MINOR, XFLOW_API_RELEASE,
	   XFLOW_API_BETA?"beta":"");
  inr_init( argc, argv, version, usage, detail); 
  if( igetopt0("--help")) {
    iusage_(usage,detail); 
    return 0;
  }
  if( igetopt0("--version")) {
    fprintf( stderr, "xflow version %s\n", version);
    return 0;
  }

#ifdef ENABLE_NLS
  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
  textdomain (GETTEXT_PACKAGE);
#endif

  //  gtk_set_locale ();
  gtk_disable_setlocale ();
  gtk_init (&argc, &argv);

  //add_pixmap_directory( ".");
  add_pixmap_directory (PACKAGE_DATA_DIR "/" PACKAGE "/pixmaps");

  /********* Init API *********/
  api . data = NULL;
  api . zpos = 0;
  api . gc = NULL;
  api . scale = 1.;
  igetopt1( "-scale", "%f", &api.scale);
  api . thresh = 0.;
  igetopt1( "-tlow", "%f", &api.thresh);
  api . thresh_high = 1000.;
  igetopt1( "-thigh", "%f", &api.thresh_high);
  api . arrowsize = 1;
  api . arrowcolor = RED;
  api . sample = 4;
  igetopt1( "-sample", "%d", &api.sample);
  if( api.sample > 30) api.sample = 30;
  if( api.sample < 1) api.sample = 1;
  api . trajs = NULL;
  api . zoom = 1;
  igetopt1( "-zoom", "%f", &api.zoom);
  if( api.zoom > 20) api.zoom = 20;
  if( api.zoom < 1) api.zoom = 1;
  norma = igetopt0("-norma");
  smooth = igetopt0("-smooth");

  /*****************************/

  debug = igetopt0( "-d");

  infileopt(name);
  color = -1;   /* Couleur du champ de vecteur, -1 = couleur par défaut */
  isimg = 0;    /* Indicateur image de fond */
  do {
  // while ( infileopt(name)) {  
    XFLOW *xfl;
    int dum;

    xfl = xflow_open_test( name, lfmt, 0);
    if( !xfl) continue; /* nom ne correspondant pas a une image valide,
			 * on ignore et on traite l'argument suivant */
    if( *lfmt) { /* C'est une image de fond  */
      struct image *img;
     
      // img = image_( name, "e", "", (void*)lfmt);
      img = (struct image *)xfl;
      api.wimg = api.wwin = NDIMX;
      api.himg = api.hwin = NDIMY;
      data = NEW(XFLOW_DATA,1);
      data->type = DATA_IMAGE;
      typescrn( img, &data->data.image.display, &data->data.image.pal);	
      assert( data->data.image.display != SCRN_UNSUPPORTED);
      data->data.image.file = img;
      data->data.image.read = NEW(unsigned char, DIMX*NDIMY);
      data->data.image.buf = NEW(unsigned char,api.wwin*api.hwin*NDIMV);

      // isimg = 1;
      api.zmax = NDIMZ;

      /* Les images sont insérées en début */
      data_insert( &api, data, 0);

    } else {    
      //      if( isimg == 0) {
	struct image *img;
	int z;
	img = xflow_get_image( xfl, lfmt);
	xflow_get_dims( xfl, &api.wwin, &api.hwin, &z);
	api.zmax = z;
	api.wimg = api.wwin;
	api.himg = api.hwin;
	if( img) {
	  //  isimg = 1;
	  data = NEW(XFLOW_DATA,1);
	  data->type = DATA_IMAGE;
	  data->data.image.file = img;
	  typescrn( img, &data->data.image.display, data->data.image.pal);
	  assert( data->data.image.display != SCRN_UNSUPPORTED);
	  data->data.image.read = NEW(unsigned char, DIMX*NDIMY);
	  data->data.image.buf  = NEW(unsigned char,api.wwin*api.hwin*NDIMV);	  
	  api.zmax = NDIMZ;
	  data_insert( &api, data, 1);
	} else
	  if(debug) 
	    fprintf( stderr, "Attention : fichier image associé non trouvé\n");
	//  }



      data = NEW(XFLOW_DATA,1);
      data->type = DATA_XFLOW;
      data->data.xflow.hide   = FALSE;
      data->data.xflow.norma  = FALSE;
      data->data.xflow.smooth = FALSE;
      data->data.xflow.arrowcolor = color ++;
      data->data.xflow.arrowsize  = -1; /* Taille vecteur : defaut */
      data->data.xflow.arrowwidth = 1;
      data->data.xflow.arrowstyle = 0;
      data->data.xflow.file = xfl;
      xflow_get_lfmt( xfl, lfmt);
      data->data.xflow.buf    = NEW(vel2d,NDIMX*NDIMY);
      /*
      data->data.xflow.magbuf = NEW(unsigned char,api.wwin*api.hwin);
      data->data.xflow.rotbuf = NEW(unsigned char,api.wwin*api.hwin);
      data->data.xflow.divbuf = NEW(unsigned char,api.wwin*api.hwin);
      */
      data->data.xflow.magbuf = NULL;
      data->data.xflow.rotbuf = NULL;
      data->data.xflow.divbuf = NULL;

      /* Les données sont insérées en fin */
      data_get_settings( &api, data);
      data_insert( &api, data, 1);  
    }
    
  } while ( infileopt(name)) ;
  
  
  /*
   * The following code was added by Glade to create one of each component
   * (except popup menus), just so that you see something after building
   * the project. Delete any components that you don't want shown initially.
   */
  api.mainwindow = create_xflow_mainwindow ();
  sprintf( name, "Xflow %d.%d.%d", XFLOW_API_MAJOR, XFLOW_API_MINOR, 
	   XFLOW_API_RELEASE);
  gtk_window_set_title( GTK_WINDOW(api.mainwindow), name);
  if(norma) gtk_button_clicked( GTK_BUTTON(lookup_widget( api.mainwindow, "xflow_normalize")));
  if(smooth) gtk_button_clicked( GTK_BUTTON(lookup_widget( api.mainwindow, "xflow_smooth")));
  /* Taille des zones de dessin */  
  gtk_widget_set_size_request ( lookup_widget( api.mainwindow, "xflow_drawing"), api.wwin, api.hwin);
  gtk_widget_set_size_request ( lookup_widget( api.mainwindow, "xflow_mag"), api.wwin, api.hwin);
  gtk_widget_set_size_request ( lookup_widget( api.mainwindow, "xflow_div"), api.wwin, api.hwin);
  gtk_widget_set_size_request ( lookup_widget( api.mainwindow, "xflow_rot"), api.wwin, api.hwin);

  gtk_widget_show (api.mainwindow);
  /* Création du contexte graphique */
  {
    GdkColor red = { 0, 1000, 0, 0 };
    widget = lookup_widget( api.mainwindow, "xflow_drawing");
    api . gc = gdk_gc_new( widget->window);
    gdk_gc_set_rgb_fg_color (api.gc, &red);
  }

  /* Lire le premier plan des données pour l'affichage */
  data_read( &api, 1);
  xflow_api_update_widget( &api);
  
  color_init( &api);
  utils_pal_init();

  //  color_set( &api, api.arrowcolor);
  utils_mesag( &api, "sequence with %d frames", NDIMZ);

  check_version();

  gtk_main ();


  /* Free API */
  if(debug) fprintf( stderr, "FIN\n");
  return 0;
}

